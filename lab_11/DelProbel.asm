.386
.model FLAT,C
public DelProbel

.CODE
DelProbel:
	push EBP           ; Сохраняем регистры согласно конвенции cdecl
	mov EBP, ESP
	push EBX
	push EDI
	push ESI

	mov EBX, [EBP+8]   ; EBX = Адрес начала строки 
	mov EAX, 0         ; EAX = '\0' (Записывается код символа '\0')
	mov EDI, EBX       ; EDI = EBX...
	cld                ; DF = 0 - строки обрабатываются по мере возрастания адреса
	repne scasb	       ; Сканируем строки до первого вхождения '\0' (DF = 0 => EDI++) пока [EDI] != AL (EAX)
	mov ECX, EDI       
	sub ECX, EBX       ; Находим длину (Это не длина строки)
	sub EDI, 2         ; Так как EDI "Перепрыгнул" '\0', нужно вернуть его на позицию символа перед '\0'

	std                ; DF = 1 - строки обрабатываются по мере убывания адресов (назад, короче)
	mov EDX, ECX       ; Сохраняем значение ECX в EDX
	mov EAX, ' '       ; Кладем код символа "пробел" в EAX, чтобы потом проверять строку на наличие непробелов
	repe scasb         ; Ищем первый символ != пробел (ECX--, EDI--)
	push ECX           ; Сохраняем оставшееся кол-во символов (без конечный пробелов)

	sub EDX, ECX       
	mov ECX, EDX
	sub ECX, 2         ; Находим кол-во удаляемых пробелов
	add EDI, 2         ; EDI опять перескачил через символ, поэтому возвращаем на позицию перед последним непробелом
	cld                ; DF = 0 - опять вперед

	mov EAX, 0         ; Записываем в EAX код символа '\0'
	rep stosb          ; Заменяем пробелы ECX раз на '\0' (EDI++)
	pop ECX            ; Восстанавливаем новое кол-во символов строки (до первого '\0')
	;add ESP, 4        ; Если что-то пойдет не так, разкомменте

CYCLE:                 ; Этот цикл можно было бы сделать эффективней путем большого сдвига, но из-за непонятных ошибок вывода пришлось сделать маленький сдвиг по циклу
	mov ESI, EBX       ; Записыавем адрес начала строки в ESI и EDI
	mov EDI, EBX
	push ECX           ; Сохраняем счетчик циклов в стеке
	lodsb              ; Читаем первый символ (ESI++)
	cmp AX, ' '        ; Если он непробел, то заканчиваем, а если нет...
	jne RETURN
	rep movsb          ; ...то мы сдвигаем все символы налево) (После этого ECX = 0)
	pop ECX            ; Восстанавливаем счетчик циклов (ECX != 0)
	loop CYCLE

RETURN:
	mov EAX, ECX       ; Присваиваем EAX результат (Это будет длина новой строки)
	pop ESI            ; Восстанавливаем регистры согласно конвенции cdecl
	pop EDI
	pop EBX
	pop EBP
	ret
END
